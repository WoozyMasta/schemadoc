// SPDX-License-Identifier: MIT
// Copyright (c) 2026 WoozyMasta
// Source: github.com/woozymasta/schemadoc

package schemadoc

import (
	"bytes"
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

// Options configures markdown rendering behavior.
//
// This model is part of the public contract and is exported as JSON Schema.
type Options struct {
	// Title is the top-level markdown heading.
	//
	// This value is rendered as `# <title>`.
	Title string `json:"title,omitempty" jsonschema:"default=schema reference,minLength=1,example=schema reference,example=My Project Config Reference"`

	// SourcePath is metadata shown in the document header.
	//
	// It does not affect schema parsing, only rendered output.
	SourcePath string `json:"source_path,omitempty" jsonschema:"example=internal/config/schema.json,example=schemas/project.schema.json"`

	// TemplateName selects one built-in template.
	//
	// Supported values:
	//
	//  - `list`
	//  - `table`
	TemplateName string `json:"template_name,omitempty" jsonschema:"default=list,enum=list,enum=table,example=list,example=table"`

	// TemplateText overrides built-in templates with custom template text.
	//
	// Use this for project-specific markdown layouts.
	TemplateText string `json:"template_text,omitempty" jsonschema:"example=# {{ .Title }}\n\nGenerated by custom template."`

	// ListMarker defines unordered markdown list marker used during description normalization.
	//
	// Supported values:
	//  - `-`
	//  - `*`
	ListMarker string `json:"list_marker,omitempty" jsonschema:"default=*,enum=-,enum=*,example=*,example=-"`

	// WrapWidth defines word-wrap width for plain description paragraphs.
	//
	// Markdown structures such as lists, blockquotes, and fenced code blocks are preserved.
	WrapWidth int `json:"wrap_width,omitempty" jsonschema:"default=80,minimum=1,example=80,example=100"`
}

// DraftInfo describes detected JSON Schema draft support status.
type DraftInfo struct {
	// Raw is the original `$schema` value from input.
	Raw string `json:"raw,omitempty" jsonschema:"example=https://json-schema.org/draft/2020-12/schema"`

	// Canonical is normalized draft alias (for example `2020-12`).
	Canonical string `json:"canonical,omitempty" jsonschema:"example=2020-12,example=draft-07"`

	// Supported reports whether draft is recognized by the renderer.
	Supported bool `json:"supported" jsonschema:"default=false"`
}

// SchemaModel is the schema root for public package models.
//
// The generator CLI (`schemadoc-schema`) reflects this type into JSON Schema.
type SchemaModel struct {
	// Options configures markdown generation.
	Options Options `json:"options" jsonschema:"required"`

	// DraftInfo is the normalized output of draft detection.
	DraftInfo DraftInfo `json:"draft_info" jsonschema:"required"`
}

// schemaDocument is the normalized JSON Schema root model used by renderer.
type schemaDocument struct {
	Root        schemaValue
	Defs        map[string]schemaValue
	RawKeywords map[string]any
	Schema      string
	ID          string
	Ref         string
	Draft       DraftInfo
}

// schemaValue stores either boolean schema or object schema.
type schemaValue struct {
	Bool   *bool
	Object map[string]any
}

// isZero reports whether schema value contains neither bool nor object schema.
func (value schemaValue) isZero() bool {
	return value.Bool == nil && value.Object == nil
}

// parseDocument decodes raw schema bytes into normalized schemaDocument model.
func parseDocument(schemaBytes []byte) (schemaDocument, error) {
	decoder := json.NewDecoder(bytes.NewReader(schemaBytes))
	decoder.UseNumber()

	var root any
	if err := decoder.Decode(&root); err != nil {
		return schemaDocument{}, fmt.Errorf("%w: %w", ErrDecodeSchema, err)
	}

	rootValue, ok := toSchemaValue(root)
	if !ok {
		return schemaDocument{}, fmt.Errorf("%w: got %T", ErrSchemaRootType, root)
	}

	doc := schemaDocument{
		Root: rootValue,
	}

	if rootObject := rootValue.Object; rootObject != nil {
		doc.RawKeywords = rootObject
		doc.Schema = asString(rootObject["$schema"])
		doc.ID = firstNonEmpty(asString(rootObject["$id"]), asString(rootObject["id"]))
		doc.Ref = asString(rootObject["$ref"])
		doc.Defs = mergeDefinitions(rootObject)
		doc.Draft = detectDraft(doc.Schema)
		return doc, nil
	}

	doc.Draft = detectDraft("")
	return doc, nil
}

// mergeDefinitions merges legacy and modern definition maps into one normalized map.
func mergeDefinitions(root map[string]any) map[string]schemaValue {
	out := make(map[string]schemaValue)
	addDefinitionMap(out, root["definitions"])
	addDefinitionMap(out, root["$defs"])
	return out
}

// addDefinitionMap adds valid schema entries from raw map into target definition map.
func addDefinitionMap(target map[string]schemaValue, raw any) {
	values, ok := raw.(map[string]any)
	if !ok {
		return
	}

	for key, item := range values {
		value, ok := toSchemaValue(item)
		if !ok {
			continue
		}

		target[key] = value
	}
}

// toSchemaValue converts bool/object raw values to normalized schemaValue.
func toSchemaValue(value any) (schemaValue, bool) {
	switch typed := value.(type) {
	case bool:
		flag := typed
		return schemaValue{Bool: &flag}, true
	case map[string]any:
		return schemaValue{Object: typed}, true
	default:
		return schemaValue{}, false
	}
}

// mapSchemaValues converts raw map values to schemaValue entries and drops invalid values.
func mapSchemaValues(value any) map[string]schemaValue {
	rawMap, ok := value.(map[string]any)
	if !ok {
		return nil
	}

	out := make(map[string]schemaValue, len(rawMap))
	for key, raw := range rawMap {
		schema, ok := toSchemaValue(raw)
		if !ok {
			continue
		}

		out[key] = schema
	}

	return out
}

// asString converts raw value to trimmed string or empty string for non-strings.
func asString(value any) string {
	text, ok := value.(string)
	if !ok {
		return ""
	}

	return strings.TrimSpace(text)
}

// asBool converts raw value to bool with conversion status.
func asBool(value any) (bool, bool) {
	flag, ok := value.(bool)
	return flag, ok
}

// asSlice converts raw value to []any slice or nil if type is different.
func asSlice(value any) []any {
	items, ok := value.([]any)
	if !ok {
		return nil
	}

	return items
}

// asStringSlice converts []any value to []string while dropping non-string entries.
func asStringSlice(value any) []string {
	items, ok := value.([]any)
	if !ok {
		return nil
	}

	out := make([]string, 0, len(items))
	for _, item := range items {
		text, ok := item.(string)
		if !ok {
			continue
		}

		out = append(out, text)
	}

	return out
}

// sortedKeys returns deterministic sorted keys for string map.
func sortedKeys(values map[string]any) []string {
	out := make([]string, 0, len(values))
	for key := range values {
		out = append(out, key)
	}

	sort.Strings(out)
	return out
}

// firstNonEmpty returns first non-empty trimmed string from input list.
func firstNonEmpty(values ...string) string {
	for _, value := range values {
		value = strings.TrimSpace(value)
		if value != "" {
			return value
		}
	}

	return ""
}

// supportedDraftAliases maps known draft aliases and schema URIs to canonical labels.
var supportedDraftAliases = map[string]string{
	"2020-12":  "2020-12",
	"2019-09":  "2019-09",
	"draft-07": "draft-07",
	"draft-06": "draft-06",
	"draft-05": "draft-05",

	"https://json-schema.org/draft/2020-12/schema": "2020-12",
	"http://json-schema.org/draft/2020-12/schema":  "2020-12",
	"https://json-schema.org/draft/2019-09/schema": "2019-09",
	"http://json-schema.org/draft/2019-09/schema":  "2019-09",
	"https://json-schema.org/draft-07/schema":      "draft-07",
	"http://json-schema.org/draft-07/schema":       "draft-07",
	"https://json-schema.org/draft-06/schema":      "draft-06",
	"http://json-schema.org/draft-06/schema":       "draft-06",
	"https://json-schema.org/draft-05/schema":      "draft-05",
	"http://json-schema.org/draft-05/schema":       "draft-05",
}

// detectDraft normalizes and resolves raw $schema value into DraftInfo metadata.
func detectDraft(raw string) DraftInfo {
	normalized := normalizeDraft(raw)
	if normalized == "" {
		return DraftInfo{Raw: raw}
	}

	canonical, ok := supportedDraftAliases[normalized]
	if !ok {
		return DraftInfo{
			Raw:       raw,
			Canonical: normalized,
			Supported: false,
		}
	}

	return DraftInfo{
		Raw:       raw,
		Canonical: canonical,
		Supported: true,
	}
}

// normalizeDraft normalizes draft strings for matching by lower-casing and trimming suffixes.
func normalizeDraft(raw string) string {
	normalized := strings.TrimSpace(strings.ToLower(raw))
	if normalized == "" {
		return ""
	}

	normalized = strings.TrimSuffix(normalized, "#")
	normalized = strings.TrimSuffix(normalized, "/")
	return normalized
}

// DetectDraft reports draft support info for a single $schema value.
func DetectDraft(schemaURI string) DraftInfo {
	return detectDraft(schemaURI)
}
